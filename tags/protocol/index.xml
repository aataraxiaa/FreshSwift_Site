<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>protocol on Fresh Swift</title>
    <link>https://freshswift.net/tags/protocol/</link>
    <description>Recent content in protocol on Fresh Swift</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 30 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://freshswift.net/tags/protocol/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Availability checking for protocol conformances</title>
      <link>https://forums.swift.org/t/availability-checking-for-protocol-conformances/42066</link>
      <pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate>
      
      <description>Swift&#39;s availability checking feature currently allows us to check if a referenced declaration is available at runtime. In this post from the official Swift forums, Slava Pestov details an extension to this feature which provides the ability to check the availability of protocol conformances.</description>
    </item>
    
    <item>
      <title>[Proposal] Static member lookup on protocol metatypes</title>
      <link>https://forums.swift.org/t/proposal-static-member-lookup-on-protocol-metatypes/41946</link>
      <pubDate>Sun, 22 Nov 2020 00:00:00 +0000</pubDate>
      
      <description>Swift currently supports static member lookup on concrete types. This improves call-site legibility by enabling us to use leading dot syntax when accessing static values. In this Swift evolution pitch, Sam Lazarus proposes extending static member lookup to protocol metatypes. This would be a nice addition, and would not have any effect of source of API stability.</description>
    </item>
    
    <item>
      <title>Unlock Existential Types for All Protocols</title>
      <link>https://forums.swift.org/t/unlock-existential-types-for-all-protocols/40665/3</link>
      <pubDate>Thu, 22 Oct 2020 00:00:00 +0000</pubDate>
      
      <description>Swift currently allows protocols that meet certain criteria to be used as types. Using a protocol in such a way essentially creates an existential type. However, protocols with associated type or self requirements cannot currently be used to create such existential types. This Swift evolution pitch proposes removing this restriction.</description>
    </item>
    
    <item>
      <title>Pitfalls of protocol extensions</title>
      <link>https://dmtopolog.com/pitfalls-of-protocol-extensions/</link>
      <pubDate>Wed, 07 Oct 2020 00:00:00 +0000</pubDate>
      
      <description>Swift protocols are an incredibly powerful language feature, allowing us to define a blueprint of methods, properties, and other requirements that suit a particular piece of functionality. It&#39;s also possible to extend protocols to implement default behavior or add additional functionality. In this post, Dmitrii Ivanov examines protocol extensions, presenting what he thinks are some drawbacks of using this language feature.</description>
    </item>
    
    <item>
      <title>Protocol extensions</title>
      <link>https://dmtopolog.com/protocol-extensions/</link>
      <pubDate>Wed, 30 Sep 2020 00:00:00 +0000</pubDate>
      
      <description>Protocols can be extended to provide method implementations to conforming types, allowing us to define behavior on protocols themselves, rather than in each type&#39;s conformance. In this post, Dmitrii Ivanov looks at how protocol extensions are used to add default implementations and additional functionality.</description>
    </item>
    
    <item>
      <title>How to declare Swift protocol for a specific class</title>
      <link>https://sarunw.com/posts/how-to-declare-swift-protocol-for-specific-class/</link>
      <pubDate>Tue, 11 Aug 2020 00:00:00 +0000</pubDate>
      
      <description>Protocols enable us to define a blueprint of methods and properties suited to a particular task. Classes, structures, and enums can then adopt protocols and provide their implementation of those methods and properties. With Swift 5, protocol definitions can constrain their conforming types to those that subclass a particular class. In this post, Sarun Wongpatcharapakorn describes how to add such a constraint and explains the benefits of doing so.</description>
    </item>
    
    <item>
      <title>Reasoning about protocols</title>
      <link>https://swiftindepth.com/2019-01-01/reasoning-about-protocols</link>
      <pubDate>Fri, 04 Jan 2019 16:47:06 +0000</pubDate>
      
      <description>This is a really nice read. Tjeerd clears up some of the confusion which may arise when using Swift protocols.</description>
    </item>
    
    <item>
      <title>What&#39;s .self, .Type and .Protocol? Understanding Swift Metatypes</title>
      <link>https://swiftrocks.com/whats-type-and-self-swift-metatypes.html</link>
      <pubDate>Thu, 08 Nov 2018 11:07:06 +0000</pubDate>
      
      <description>Bruno Rocha digs in to Swift metatypes. He first explains what a metatype is, before highlighting the differences between dynamic and static metatypes.</description>
    </item>
    
    <item>
      <title>Specializing Protocols in Swift</title>
      <link>https://www.swiftbysundell.com/posts/specializing-protocols-in-swift</link>
      <pubDate>Tue, 30 Oct 2018 13:56:25 +0000</pubDate>
      
      <description>John Sundell shows us how we can use protocols to create multiple levels of abstraction, allowing us to start out with a more general protocol that we can then specialize.</description>
    </item>
    
    <item>
      <title>Evolution- Default Implementation In Protocols</title>
      <link>https://forums.swift.org/t/default-implementation-in-protocols/15794/8</link>
      <pubDate>Sun, 09 Sep 2018 08:40:17 +0000</pubDate>
      
      <description>Alejandro Alonso has been working on a Swift language change to allow default method implementations in protocol definitions. This thread is a discussion among community members of the pros and cons of this proposal.</description>
    </item>
    
    <item>
      <title>Value-Oriented Programming </title>
      <link>https://matt.diephouse.com/2018/08/value-oriented-programming/</link>
      <pubDate>Sun, 02 Sep 2018 10:43:28 +0000</pubDate>
      
      <description>Matt Diephouse describes value-oriented programming, an approach he uses which builds on protocol-oriented programming, adding the benefits that value types can provide.</description>
    </item>
    
    <item>
      <title>Retroactive Conformances vs. Swift-in-the-OS</title>
      <link>https://forums.swift.org/t/retroactive-conformances-vs-swift-in-the-os/14393</link>
      <pubDate>Sat, 21 Jul 2018 15:24:33 +0000</pubDate>
      
      <description>This is an interesting Swift evolution discussion started by Jordan Rose which looks at problems encountered when retroactively conforming a type to a protocol. Jordan first describes the problems before proposing a rule which might help to avoid them.</description>
    </item>
    
    <item>
      <title>Watch out for protocol extensions in your Swift API </title>
      <link>https://medium.com/@londeix/watch-out-for-protocol-extensions-in-your-swift-api-unit-tests-trap-e28ad4ef3268</link>
      <pubDate>Mon, 07 May 2018 12:32:32 +0000</pubDate>
      
      <description>Bartosz Polaczyk looks at a potential gotcha relating to testing code defined in Swift protocol extensions. As a companion to this article, I also recommend reading the excellent article from Raizlabs which Bartosz links to, which looks in detail at method dispatching in Swift.</description>
    </item>
    
    <item>
      <title>Understanding protocol associated types and their constraints</title>
      <link>https://www.hackingwithswift.com/articles/74/understanding-protocol-associated-types-and-their-constraints</link>
      <pubDate>Wed, 11 Apr 2018 12:07:20 +0000</pubDate>
      
      <description>Paul Hudson dives into Swift protocols and associated types. Paul explains why protocol associated types are so powerful, before showing us how best control their complexity using constraints.</description>
    </item>
    
    <item>
      <title>Conditional conformances in Swift</title>
      <link>https://www.swiftbysundell.com/posts/conditional-conformances-in-swift</link>
      <pubDate>Sat, 07 Apr 2018 10:34:47 +0000</pubDate>
      
      <description>John Sundell looks at Conditional Conformance, a new Swift feature included in the recent Swift 4.1 release. Conditional conformance is a great addition to the language, and John demonstrates how we can use it to write code in a recursive fashion, while reducing duplication.</description>
    </item>
    
    <item>
      <title>Dependency Mixins in Swift using Protocol-Oriented-Programming</title>
      <link>https://chickenwing.software/scratches/programming/swift-programming/swift-dependency-mixin?utm_source=newsletter_mailer&amp;utm_medium=email&amp;utm_campaign=weekly</link>
      <pubDate>Sun, 01 Apr 2018 13:11:05 +0000</pubDate>
      
      <description>Eddie Sullivan describes an approach to handling dependencies between types. Eddie looks at the idea of using protocol-based mixins to reduce coupling. Although this is not exactly the approach I would take, it’s always worth learning about how others approach a common problem.</description>
    </item>
    
    <item>
      <title>Caveats of Swift default protocol extensions</title>
      <link>http://www.marisibrothers.com/2018/03/caveats-of-swift-default-protocol.html?m=1</link>
      <pubDate>Fri, 30 Mar 2018 15:08:02 +0000</pubDate>
      
      <description>In this post, Luciano Marisi outlines two good reasons why we should be careful when adding default implementations in Swift protocol extensions.</description>
    </item>
    
    <item>
      <title>Swift Tip: Extensible Libraries with Protocols</title>
      <link>https://www.objc.io/blog/2018/02/27/extensible-libraries-with-protocols</link>
      <pubDate>Tue, 13 Mar 2018 07:26:14 +0000</pubDate>
      
      <description>This post from the Objc.io team demonstrates how we can build extensible, type-safe Swift libraries using protocol composition.</description>
    </item>
    
    <item>
      <title>Swift Protocols Wishlist</title>
      <link>https://davedelong.com/blog/2018/02/08/swift-protocols-wishlist/</link>
      <pubDate>Sun, 04 Mar 2018 19:41:48 +0000</pubDate>
      
      <description>Dave Delong shares his wishlist of what he would change about how Swift deals with protocols. It’s a solid list, and although I have not hit every pain point he mentions,  I can’t say I disagree with any of his wishes.</description>
    </item>
    
    <item>
      <title>Conditional Conformance</title>
      <link>https://swiftunboxed.com/lang/conditional-conformance/?utm_source=Swift_Developments&amp;utm_medium=email&amp;utm_campaign=Swift_Developments_Issue_122</link>
      <pubDate>Thu, 15 Feb 2018 10:51:33 +0000</pubDate>
      
      <description>Greg Heo thinks through conditional conformance in Swift, showing us what it’s good for, and how it works.</description>
    </item>
    
    <item>
      <title>Conditional Conformance in the Standard Library</title>
      <link>https://swift.org/blog/conditional-conformance/?utm_source=newsletter_mailer&amp;utm_medium=email&amp;utm_campaign=weekly</link>
      <pubDate>Sun, 11 Feb 2018 09:38:07 +0000</pubDate>
      
      <description>This post by Ben Cohen on the official Swift blog describes how Swift 4.1’s conditional protocol conformance feature has been utilised in the Swift standard library.</description>
    </item>
    
    <item>
      <title>Why Associated Type Requirements Become Generic Constraints</title>
      <link>https://www.bignerdranch.com/blog/why-associated-type-requirements-become-generic-constraints/</link>
      <pubDate>Sat, 27 Jan 2018 12:25:20 +0000</pubDate>
      
      <description>Jeremy Sherman looks at Swift protocols which have associated types. He compares Swift protocols with Objective-C protocols, and for the more curious reader, he considers whether Self is an associated type or not.</description>
    </item>
    
    <item>
      <title>Replacing legacy code using Swift protocols</title>
      <link>https://www.swiftbysundell.com/posts/replacing-legacy-code-using-swift-protocols</link>
      <pubDate>Tue, 12 Sep 2017 07:32:07 +0000</pubDate>
      
      <description>Legacy code is often best dealt with on an ongoing basis, refactoring in small steps rather than trying to refactor large chunks. In this post, John Sundell describes his approach to refactoring legacy code, based on using Swift protocols to refactor in steps without breaking too much.</description>
    </item>
    
    <item>
      <title>Protocol composition in Swift and Objective-C</title>
      <link>http://www.jessesquires.com/blog/protocol-composition-in-swift-and-objc/</link>
      <pubDate>Tue, 20 Jun 2017 07:41:23 +0000</pubDate>
      
      <description>Protocols are a powerful tool. They allow us to specify contracts between classes that consume them, while also allowing us to segregate interfaces and invert control. However, when we want to declare protocol members as optional, we are forced to diminish the robustness of our code. In this post, Jesse Squires examines this problem, and proposes a number of approaches to make dealing with optional protocol members a bit more robust. One of these approaches, using nested protocols, is particularly elegant.</description>
    </item>
    
    <item>
      <title>Protocols and MVVM in Swift to avoid repetition</title>
      <link>https://sudo.isl.co/swift-mvvm-protocols/</link>
      <pubDate>Tue, 23 May 2017 07:37:03 +0000</pubDate>
      
      <description>Thomas Degry demonstrates how we can use MVVM and protocols to avoid achieve two goals: avoiding massive view controllers (MVC!), and having as little repetitive code as possible. It&#39;s a nice simple use of a protocol to create a more generic table view, and it&#39;s something I have myself used in projects.</description>
    </item>
    
    <item>
      <title>Loose coupling using Swift protocols</title>
      <link>http://www.apokrupto.com/blog-1/2017/5/16/default-protocol-extensions-for-loose-coupling</link>
      <pubDate>Mon, 22 May 2017 18:19:34 +0000</pubDate>
      
      <description>Nice usage of a Swift protocol and default implementation to achieve loose coupling. The post looks at the iOS AppDelegate class, but this approach could be used with any type.</description>
    </item>
    
    <item>
      <title>Swift Protocols as UI Mixins</title>
      <link>http://cleancocoa.com/posts/2017/04/protocol-ui-mixin/</link>
      <pubDate>Tue, 02 May 2017 16:51:47 +0000</pubDate>
      
      <description>Christian Tietze comments on a GitHub gist which adds pull to refresh to a UITableView. The gist is a nice example of using a Swift protocol with a default implementation to add functionality to a UI element.</description>
    </item>
    
    <item>
      <title>Dependency injection via protocol composition</title>
      <link>http://merowing.info/2017/04/using-protocol-compositon-for-dependency-injection</link>
      <pubDate>Mon, 17 Apr 2017 08:19:18 +0000</pubDate>
      
      <description>Krzysztof Zablocki with a nice approach to dependency injection based on protocol composition. Avoid constantly refactoring code callsites while keeping your code testable.</description>
    </item>
    
  </channel>
</rss>
